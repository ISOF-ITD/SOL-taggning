q
@currelem
n
head.capitalised?
head
q
reformat_head
c
par2.to_s
XPath.first(par2, 'p/span[@type="fet"]')
XPath.first(par, 'p/span[@type="fet"]')
par2 = solig.unword(al2, false)
al2 = allal.elements[2]
al2 = allall.elements[2]
XPath.first(par, 'p/span[@type="fet"]')
XPath.first(par, 'p/span').attributes['type']
XPath.first(par, 'p/span[type=fet]')
XPath.first(par, 'p/span[type="fet"]')
par.class
par.name
XPath.first(par, 'div/p/span')
XPath.first(par, 'p/span')
XPath.first(par, 'div/span')
XPath.first(par, 'dov/span')
XPath.first(par, '//span')
XPath.first(par, 'span')
par = solig.unword(al, false)
c
q
solig.unword(al, false).to_s
c
solig.unword(al, false).to_s
solig.unword(al, false).to-s
q
solig.unword(al, false).to_s
c
@currtext
n
@currtext
@currelem.to_s
n
@currelem.to_s
locale.strip
locale
n
c
reformat_head
n
@currelem.to_s
@currelem
@currtext
locale
c
@currtext
@cuurtext
q
qq
puts al.to_s
puts _
al.to_s
c
allal.elements.count
allal.root.elements.count
allal
allall
c
pars.root.elements.count
pars.elements.count
pars.class
c
element = ret.root.elements.first
ret.root.elements.count
c
head.to_s
head = ret.elements.first.elements.first
head = ret.elements.first
ret.root.name
ret.name
ret
ret.class
q
self
r
c
q
doc.root.elements.count
doc.root.elements
doc.root
doc
q
actual
expected
expected == actual
c
actual
expected
expected == actual
c
q
c
q
actual
expected
expected == actual
c
q
@currelem.to_s
n
reformat_head
c
actual
expected
expected == actual
expected == actuall
c
reformat_head
c
q
s
reformat_head
c
reformat_head
q
actual
expected
expected == actual
c
actual
expected
expected == actual
c
actual
expected
expected == actual
c
actual
expected
expected == actual
q
expected
actual
actual.to_s
c
actual
expected
c
@currelem.to_s
n
@currelem.to_s
n
@currelem.to_s
@currelem
n
@currelem.root.to_s
n
@currelem.root.to_s
reformat_head
q
c
@currelem.to_s
n
@currelem.root.to_s
@currelem.to_s
span_element.to_s
n
span_element.to_s
span
n
reformat_head
n
self
s
n
s
q
n
c
n
@r.wtext
s
c
n
reformat_head
element.each_element('w:r/w:t') { }.join
element.to_s
@r.wtext
r.wtext
c
unword(element)
element
formatted
c
actual.length.times { |n| puts n unless actual[n] == expected[n] }
expected == actual
actual
expected
q
actual
expected
c
actual
expected
c
actual
expected
c
actual
expected
c
actual
expected
c
actual
expected
expected == actual
q
location_element.text
location_element
c
actual
expected
expected == actual
c
expected
expected == actual
c
solig.unword(bro).to_s
c
actual[455..486]
expected[455..486]
expected[752].ord
expected[413].ord
actual[88..93]
expected[88..93]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual
expected
expected == actual
c
actual
expected
expected == actual
c
actual
expected
actual == expected
c
expected == actual
c
actual
expected
expected == actual
c
actual
expected
expected == actual
