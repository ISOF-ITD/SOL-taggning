c
q
c
q
c
xml.to_s == expected
xml.to_s
loc.remove
loc.to_s
loc = XPath.first(xml, '//location')
xml = Document.new actual
expected == actual
actual
expected
q
location.to_s == '<location/>'
location.to_s
location.text
location = XPath.first(@currelem.root, '//location')
XPath.first(@currelem.root, 'location')
location
locatio
c
xml.to_s == expected
xml.to_s
p.to_s
p
loc.remove
p.remove(loc)
loc = XPath.first(xml.root.elements[2], 'location')
p[1]
p[0]
[0]
p[3]
p[2]
p[1]
p[2]
p.respond_to? :remove
p.respond_to? :remove_element
p.class
p = xml.root.elements[2]
XPath.first(xml.root.elements[2], 'location')
xml.root.elements[2]
xml.root.elements[2].elements[1].text
xml.root.elements[2].elements[1].name
xml.root.elements[2].to_s
xml.root.elements[2].to)s
xml.root.elements[2].elements[2].name
xml.root.elements[2].elements.last
xml.root.elements[2].elements[1].attribute('type').class
_.class
xml.root.elements[2].elements[1].attribute 'type'
xml.root.elements[2].elements[1].attributes['type']
xml.root.elements[2].elements[1].name
xml.root.elements[2].elements[1]
xml.root.elements[2].elements.count
xml.root.elements[2].name
xml.root.name
xml.name
xml.root.elements.first.name
xml = Document.new actual
actual
expected
c
@state
n
@state
n
c
q
@currtext
r.text_bit
rs.count
n
q
n
next
bt
c
@currtext =~ /^.*?,\s*/
@currtext =~ /,/
@currtext
c
q
@currtext
q
rs.count
n
rs.count
n
rs.count
q
@currelem.to_s
n
@currtext
n
r.text_bit
@currtext
@currelem.to_s
c
actual
expected
expectd
c
expected == actual
c
@currelem.to_s
@currtext
@carryover
r.text_bit
c
@currelem.to_s
rs.count
r
c
actual == expected
q
actual
expected == actual
c
q
y
w
c
formatted.to_s
c
@currelem.parent.to_s
@currelem.parent
@currelem
n
@state
n
rs.count
r.text_bit
@currelem.to_s
n
@currelem.root.to_s
@currelem.to_s
n
@carryover
@currelem.to_s
n
@currtext
@carryover
@state
r.text_bit
@currtext
3 ^ 5
3 ^ 1
3 ^ 2
false ^ false
true ^ true
true ^ false
false ^ true
false.respond_to? :^
false.respond_to? :^^
1 ^ 0
r.isitalic?
@carryover
@currtext
n
@state
r.text_bit
rs.count
@currelem.to_s
c
@currelem.to_s
c
@currelem.to_s
c
q
n
r.text_bit
rs.first.text_bit
rs.first.isitalic?
rs.first
n
@currtext
@currelem.root.to_s
@state
@currtext
n
@state
@currelem.root.to_s
c
@currelem.root.to_s
@currelem.to_s
@currelem.to-s
@currtext
r.text_bit
@state
c
rs.map(&:text_bit)
r.text_bit
q
bt
q
c
q
r.text_bit
r
rs.map(&:text_bit)
rs.count
q
rs.count
rs.first
r.text_bit
q
bt
q
ucklum.each_element('w:r/w:t') { }.join
ucklum
up
@state
r.text_bit
n
@state
r.text_bit
c
r.text_bit
@state
c
r.text_bit
@state
c
@state
r.isitalic?
@state
r.text_bit
c
@state
r.text_bit
c
@state
r.text_bit
q
actual
expected
q
c
actual
c
@currtext
@currelem.root.to_s
@currelem.name
@state
n
@currelem.to_s
n
@currelem.to_s
n
@currtext
@currelem.to_s
c
q
@currtext
