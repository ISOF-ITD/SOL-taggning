q
carryover
c
tail
separator
location
state
r.text_bit
c
r.text_bit
state
carryover
q
actual[239..312]
expected[239..312]
expected[239..256]
actual[239..256]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual == expected
c
location
loc
ct
index
state
location
q
n
ct
n
location
separator
tail
n
carryover
state
r.text_bit
r.text-bit
c
state
r.text_bit
div.to_s
p.parent
p.to_s
p.text
p
c
n
location
n
r.text_bit.strip
r.text_bit
state
n
state
n
carryover
state
r.text_bit
c
carryover
state
r.text_bit
c
state
r.text_bit
c
state
r.text_bit
c
state
r.text_bit
c
r.text_bit
state
c
state
c
state
r.text_bit
c
state
r.text_bit
c
state
r.text_bit
c
actual
c
actual
expected
actual[88..112]
expected[88..112]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
expected
actual.length.times { |n| puts n unless actual == expected }
actual == expected
r.text_bit
c
actual
expected
expected[88..112]
actual[88..112]
actual[88.112]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual.length.times { |n| puts unless actual[n] == expected[n] }
actual == expected
q
c
actual == expected
r.text_bit
c
state
r.text_bit
c
r.text_bit
state
c
r.text_bit
c
r.text_bit
c
state
r.text_bit
c
state
r.text_bit
c
q
state
r.text_bit
c
state
r.text_bit
c
r.text_bit
c
r.text_bit
actual == expected
n
p.parent
p
n
r.text_bit
state
c
r.text_bit
state
satte
c
state
q
state
c
state
c
state
c
state
c
state
r.text_bit
c
r.text_bit
c
r.text_bit
c
r.isitalic
r.italic
r.isbold
r.is_bold
REXML::XPath.first(r, 'w:rPr/w:b')
REXML::XPath.first(r, 'w:rPr/w:i')
REXML::XPath.first(r, 'w:rPr')
REXML::XPath.first(r, 'w:t').text
REXML::XPath.first(r, 'w:t')
r.attributes
r.text_bit
r
q
c
kc
actual
expected[256..296]
actual[256..296]
actual[262..296]
expected[262..296]
expected[239..256]
actual[239..256]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
c
a[3]
a = [1]
expected
expected[239..256]
actual
expected[239..256]
actual[239..256]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual.length.times { |n| puts n unless actual[n] == expeced[n] }
actual.length.times { |n| puts n unlesss actual[n] == expected[n] }
actual == expected
c
form.to_s
q
p.to_s
n
locale
p.to_s
n
locale
n
tail
separator
location
n
start
n
p.elements.count
p.text
p
p.parent
div.to_s
div.elements.first.elements.first.text
div.elements.first.elements.first.tedxt
div.elements.first.elements.first.name
div.elements.first.elements.count
div.elements.first.text
div.elements.first.name
div.elements.first.map
div.elements.count
div.text
n
p.parent
carryover
div.text
div
n
c
r.text_bit
c
r.text_bit
q
state
c
state
c
state
c
state
q
form.to_s
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>t/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>t√§tort/
