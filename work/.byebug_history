c
actual == expected
q
expected
actual
actual == expected
q
r.isitalic?
r.text_bit
c
r.text_bit
c
r.text_bit
c
r.text_bit
c
r.text_bit
c
r.text_bit
c
r.text_bit
c
@state
state
r.text_bit
c
expected[460..500]
actual[460..500]
actual[460..480]
expected[460..480]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual
expected
expeccted
c
t
n
t
n
state
carryover
r.text_bit
n
r.text_bit
c
r.text_bit
c
r.text_bit
q
div.to_s
r.text_bit
c
div.to_s
r.text_bit
q
r.text_bit
c
r.text_bit
c
q
actual
c
actual[342..376]
expected[342..376]
actual[278]
expected[278]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual == expected
c
actual[192..216]
expected[192..216]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual
expected
c
actual
expected
c
q
ps[6344].each_element('w:r/w:t') { }.join
state
n
p.parent
p
n
r.text_bit
state
c
r.text_bit
state
satte
c
state
q
state
c
state
c
state
c
state
c
state
r.text_bit
c
r.text_bit
c
r.text_bit
c
r.isitalic
r.italic
r.isbold
r.is_bold
REXML::XPath.first(r, 'w:rPr/w:b')
REXML::XPath.first(r, 'w:rPr/w:i')
REXML::XPath.first(r, 'w:rPr')
REXML::XPath.first(r, 'w:t').text
REXML::XPath.first(r, 'w:t')
r.attributes
r.text_bit
r
q
c
kc
actual
expected[256..296]
actual[256..296]
actual[262..296]
expected[262..296]
expected[239..256]
actual[239..256]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
c
a[3]
a = [1]
expected
expected[239..256]
actual
expected[239..256]
actual[239..256]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual.length.times { |n| puts n unless actual[n] == expeced[n] }
actual.length.times { |n| puts n unlesss actual[n] == expected[n] }
actual == expected
c
form.to_s
q
p.to_s
n
locale
p.to_s
n
locale
n
tail
separator
location
n
start
n
p.elements.count
p.text
p
p.parent
div.to_s
div.elements.first.elements.first.text
div.elements.first.elements.first.tedxt
div.elements.first.elements.first.name
div.elements.first.elements.count
div.elements.first.text
div.elements.first.name
div.elements.first.map
div.elements.count
div.text
n
p.parent
carryover
div.text
div
n
c
r.text_bit
c
r.text_bit
q
state
c
state
c
state
c
state
q
form.to_s
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>t/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>tätort/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>tätort<\/span>/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn</span>, <span type='locale'>tätort</span>/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head>/
q
REXML::XPath.first(doc.root.elements.first, 'w:rPr/w:i')
doc.root.elements.first
doc.root.name
doc.root.isitalic
doc.isitalic
quit
c
foo.to_s
n
foo.to_s
n
span.parent
span
locale.to_s
to_s
self.to_s
self
locale.parent
locale
quit
locale.parent
locale
q
index
loc
REXML::XPath.first(r, 'w:t').text
q
actual[203..220]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual == expected
q
p.to_s
p
n
ct
index
n
loc
n
loc
n
type
tag
n
p.to_s
p
div.to_s
div
REXML::XPath.first(r, 'w:t').text
tag
q
qy
formatted.to_s[459..470]
expected[459..470]
