c
state
c
state
r.text_bit
c
state
r.text_bit
c
state
r.text_bit
c
actual
c
actual
expected
actual[88..112]
expected[88..112]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
expected
actual.length.times { |n| puts n unless actual == expected }
actual == expected
r.text_bit
c
actual
expected
expected[88..112]
actual[88..112]
actual[88.112]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual.length.times { |n| puts unless actual[n] == expected[n] }
actual == expected
q
c
actual == expected
r.text_bit
c
state
r.text_bit
c
r.text_bit
state
c
r.text_bit
c
r.text_bit
c
state
r.text_bit
c
state
r.text_bit
c
q
state
r.text_bit
c
state
r.text_bit
c
r.text_bit
c
r.text_bit
actual == expected
n
p.parent
p
n
r.text_bit
state
c
r.text_bit
state
satte
c
state
q
state
c
state
c
state
c
state
c
state
r.text_bit
c
r.text_bit
c
r.text_bit
c
r.isitalic
r.italic
r.isbold
r.is_bold
REXML::XPath.first(r, 'w:rPr/w:b')
REXML::XPath.first(r, 'w:rPr/w:i')
REXML::XPath.first(r, 'w:rPr')
REXML::XPath.first(r, 'w:t').text
REXML::XPath.first(r, 'w:t')
r.attributes
r.text_bit
r
q
c
kc
actual
expected[256..296]
actual[256..296]
actual[262..296]
expected[262..296]
expected[239..256]
actual[239..256]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
c
a[3]
a = [1]
expected
expected[239..256]
actual
expected[239..256]
actual[239..256]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual.length.times { |n| puts n unless actual[n] == expeced[n] }
actual.length.times { |n| puts n unlesss actual[n] == expected[n] }
actual == expected
c
form.to_s
q
p.to_s
n
locale
p.to_s
n
locale
n
tail
separator
location
n
start
n
p.elements.count
p.text
p
p.parent
div.to_s
div.elements.first.elements.first.text
div.elements.first.elements.first.tedxt
div.elements.first.elements.first.name
div.elements.first.elements.count
div.elements.first.text
div.elements.first.name
div.elements.first.map
div.elements.count
div.text
n
p.parent
carryover
div.text
div
n
c
r.text_bit
c
r.text_bit
q
state
c
state
c
state
c
state
q
form.to_s
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>t/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>tätort/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn<\/span>, <span type='locale'>tätort<\/span>/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head> <p><span type='locale'>sn</span>, <span type='locale'>tätort</span>/
form.to_s =~ /^<div><head><placeName>Husby<\/placeName><\/head>/
q
REXML::XPath.first(doc.root.elements.first, 'w:rPr/w:i')
doc.root.elements.first
doc.root.name
doc.root.isitalic
doc.isitalic
quit
c
foo.to_s
n
foo.to_s
n
span.parent
span
locale.to_s
to_s
self.to_s
self
locale.parent
locale
quit
locale.parent
locale
q
index
loc
REXML::XPath.first(r, 'w:t').text
q
actual[203..220]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual == expected
q
p.to_s
p
n
ct
index
n
loc
n
loc
n
type
tag
n
p.to_s
p
div.to_s
div
REXML::XPath.first(r, 'w:t').text
tag
q
qy
formatted.to_s[459..470]
expected[459..470]
expected.length.times { |n| puts n unless expected[n] == formatted.to_s[n] }
expected.length { |n| puts n unless expected[n] == formatted.to_s[n] }
expected.length { |n| puts n ubless expected[n] == formatted.to_s[n] }
expected.length { |n| puts n u less expected[n] == formatted.to_s[n] }
expected == formatted.to_s
c
expected.length { |n| puts n u less expected[n] == formatted.to_s[n] }
expected == formatted.to_s
q
qy
formatted.to_s[423..450]
expected[423..450]
expected.length.times { |n| puts n unless expected[n] == formatted.to_s[n] }
expected == formatted.to_s
q
formatted.to_s[334..350]
expected[334..350]
