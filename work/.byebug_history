q
n
location
n
nil.respond_to? :=~
tail
n
separator
locale
separator
@currelem.parent.to_s
@currelem.to_s
locale
n
locale
n
first
n
locale
location
@carryover.split ','
@carryover
location
n
r.text_bit
@carryover
@currelem.parent.to_s
@currelem.to_s
n
@state
r.object_id
n
r.object_id
r.objectr_id
eval i
n
@state
eval i
r.text_bit
n
eval i
@carryover
@currelem.parent.to_s
@currelem.to_s
n
@currelem.to_s
n
@currelem.to_s
@currelem.to-s
n
@carryover
n
@currelem.to_s
@state
@carryover
r.text_bit
c
actual
c
actual
expected
c
expected == actual
c
actual
expected
expected == actual
c
actual
expected
expected == actual
c
rs.map { |r| REXML::XPath.first(r, 'w:t').text }
REXML::XPath.first(r, 'w:t').text
r.text_bit
rs.map { |r| REXML::XPath.first(r, 'w:r/w:t').text }
rs
eval i
i
@carryover
@state
r.text_bit
c
@state
r.text_bit
c
@state
r.text_bit
c
@state
state
r.text_bit
q
div
c
bt
element
n
s
solig
div
c
Solig.is_landskap? self
c
@currelem.parent.to_s
@currelem.name
@currelem.to_s
@currelemen.name
@currelemen.to_s
first
@currlement.name
@currlement.to_s
r.text_bit
location
locale
c
actual == expected
q
expected
actual
actual == expected
q
r.isitalic?
r.text_bit
c
r.text_bit
c
r.text_bit
c
r.text_bit
c
r.text_bit
c
r.text_bit
c
r.text_bit
c
@state
state
r.text_bit
c
expected[460..500]
actual[460..500]
actual[460..480]
expected[460..480]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual
expected
expeccted
c
t
n
t
n
state
carryover
r.text_bit
n
r.text_bit
c
r.text_bit
c
r.text_bit
q
div.to_s
r.text_bit
c
div.to_s
r.text_bit
q
r.text_bit
c
r.text_bit
c
q
actual
c
actual[342..376]
expected[342..376]
actual[278]
expected[278]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual == expected
c
actual[192..216]
expected[192..216]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual
expected
c
actual
expected
c
q
ps[6344].each_element('w:r/w:t') { }.join
state
n
p.parent
p
n
r.text_bit
state
c
r.text_bit
state
satte
c
state
q
state
c
state
c
state
c
state
c
state
r.text_bit
c
r.text_bit
c
r.text_bit
c
r.isitalic
r.italic
r.isbold
r.is_bold
REXML::XPath.first(r, 'w:rPr/w:b')
REXML::XPath.first(r, 'w:rPr/w:i')
REXML::XPath.first(r, 'w:rPr')
REXML::XPath.first(r, 'w:t').text
REXML::XPath.first(r, 'w:t')
r.attributes
r.text_bit
r
q
c
kc
actual
expected[256..296]
actual[256..296]
actual[262..296]
expected[262..296]
expected[239..256]
actual[239..256]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
c
a[3]
a = [1]
expected
expected[239..256]
actual
expected[239..256]
actual[239..256]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
