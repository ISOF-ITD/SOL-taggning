q
n
REXML::XPath.first(r, 'w:t').text
div.to_s
n
pp div
require 'pp'
div.to_s
REXML::XPath.first(r, 'w:t').text
state
c
REXML::XPath.first(r, 'w:t').text
c
q
div.to_s
c
div.to_s
state
c
state
div.to_s
c
q
div.to_s
state
c
n
location_element.to_s
n
ct
n
location
n
location
n
location
locale
n
locale
n
locale
n
$3
$2
$1
n
REXML::XPath.first(r, 'w:t').text.strip
n
state
div.to_s
c
n
locale
p.to_s
eval p
n
locale
n
start
location
n
start
location
n
start
n
carryover
n
REXML::XPath.first(r, 'w:t').text
state
c
REXML::XPath.first(r, 'w:t').text
state
sdtate
div.elements.first.to_s
div.elements.first.text
div.elements.first.name
div.elements.name
div.elements.count
div
p.parent
p.respond_to? :parent
p
REXML::XPath.first(r, 'w:t').text
state
c
REXML::XPath.first(r, 'w:t').text
REXML::XPath.first(r, 'w:t')
REXML::XPath.new(r, 'w:t')
REXML::XPath(r, 'w:t')
state
c
state
continue
formatted.elements.map(&:name)
formatted.elements.count
formatted
q
expected[540..-1]
expected.length
formatted.to_s[540..-1]
formatted.to_s.length
formatted.to_s[579..-1]
expected[579..-1]
expected.length.times { |n| puts n unless expected[n] == formatted.to_s[n] }
expected == formatted.to_s
expected = "<div><head>Ucklum</head> <p><span type='locale'>sn</span>, <span type='locale'>tätort</span>, <location><district type='härad'>Inlands Nordre hd</district><region type='landskap'>Bohuslän</region></location>. <span style='italic'>Auklanda kirkia</span> 1388. – Socknen har fått sitt namn efter kyrkbyn (numera tätort). Det kan vara identiskt med det från sydvästra Norge kända <span style='italic'>Aukland</span>, som har antagits innehålla ett ord med betydelsen ’ökat eller tillfogat land, nyodling’. Det är här i så fall fråga om en mycket tidig nyodling till byn Grössby.</p></div>"
c
q
formatted.to_s[557..586]
expected[557..586]
expected[464]
expected[n]
expected.length.times { |n| puts n unless expected[n] == formatted.to_s[n] }
expected == formatted.to_s
expected = "<div><head>Ucklum</head> <p><span type='locale'>sn</span>, <span type='locale'>tätort</span>, <location><district type='härad'>Inlands Nordre hd</district><region type='landskap'>Bohuslän</region></location>. <span style='italic'>Auklanda kirkia</span> 1388. – Socknen har fått sitt namn efter kyrkbyn (numera tätort). Det kan vara identiskt med det från sydvästra Norge kända <span style='italic'>Aukland</span>, som har antagits innehålla ett ord med betydelsen ‘ökat eller tillfogat land, nyodling’. Det är här i så fall fråga om en mycket tidig nyodlinge till byn Grössby.</p></div>"
expected == actual
q
locale =~ /^\s*([^\s]+)\s*/
locale
n
locale =~ /^\s*([^\s]+)\s*/
!locale.strip.is_landskap
c
!locale.strip.is_landskap
locale =~ /^\s*([^\s]+)\s*/
q
c
locale =~ /^\s*([^\s]+)\s*/
!locale.strip.is_landskap
c
!locale.strip.is_landskap
locale =~ /^\s*([^\s]+)\s*/
q
locale
n
locale =~ /^\s*([^\s]+)\s*$/
locale
n
locale
locale.strip.is_landskap
locale =~ /^\s*([^\s]+)\s*$/
locale
c
locale
q
locale.is_landskap
locale =~ /^\s*([^\s]+)\s*$/
locale
n
locale =~ /^\s*([^\s]+)\s*$/
locale =~ /^\s([^\s]+)\s*$/
locale =~ /^\s*([^\s]+)\s*$/
locale =~ /([^\s]+)/
locale
locale =~ /^\s([^\s]+)\s*$/
locale.is_landskap
locale
locale =~ /^\s([^\s]+)\s*/
state
q
start
q
REXML::XPath.first(r, 'w:t').text
c
REXML::XPath.first(r, 'w:t').text
c
REXML::XPath.first(r, 'w:t').text
c
REXML::XPath.first(r, 'w:t').text
c
REXML::XPath.first(r, 'w:t').text
c
REXML::XPath.first(r, 'w:t').text
REXML::XPath.first(r, 'w:r/w:t').text
c
q
start
n
start
n
state
c
state
c
state
q
puts r.to_s
state
c
puts r.to_s
state
c
puts r.to_s
r.text
state
c
state
q
c
puts r.to_s
r.to_s
c
q
c
start
n
div.to_s
div
carryover
q
location
locale
c
location
locale
c
location
locale
c
location
locale
c
location
locale
q
location
locale
n
location
locale
inlocale
q
location
c
actual == expected
q
actual[425]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual == expected
q
actual[417..444]
expected[417..444]
actual == expected
c
foo.strip!
foo = ' foo '
expected[417..444]
actual[417..444]
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual[329..350]
actual == expected
q
actual[329..350]
expected[329..350]
expected[283..300]
