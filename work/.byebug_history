c
child.text.to_s
child.text
child
c
actual
c
actual
c
element.to_s
child
c
element.to_s
child
c
element.to_s
child
c
element.to_s
child.to_s
q
child
c
q
child
c
child
c
actual
expected
expected == actual
q
expected == actual
c
child
child.is_kursiv?
n
belägg
c
n
belägg
n
belägg
n
belägg
$1
n
belägg
n
belägg
c
belägg
n
belägg
c
child.is_opening_parenthesis?
c
actual
expected
expecte
actual == expected
c
actual
expected
c
actual
expected
c
q
child.to_s =~ /^\s*(…|\.\.\.)?\)\s+$/
child.to_s =~ / …? $/
child.to_s =~ /…? $/
child.to_s =~ /^\) …? $/
child.to_s =~ /^\)\s…?\s$/
child.to_s =~ /^\)\s+…?\s$/
child.to_s =~ /^\)\s+(…)?\s$/
child.to_s =~ /^\)\s+(…|\.\.\.)?\s$/
child.to_s =~ /^\)\s+(…|\.\.\.)?\s*$/
child
c
actual == expected
actual == expecte
c
actual.length.times { |n| puts n unless actual[n] == expected[n] }
actual.length.each { |n| puts n unless actual[n] == expected[n] }
actual.length == expected.length
actual
expected
actual == expected
c
actual
expected
actual == expected
q
actual
expected
actual == expected
q
state
child
state
q
c
element.to_s
element
q
actual
c
actual
c
XPath.first(akalla, 'p').texts.map(&:to_s)
XPath.first(ak, 'p').texts.map(&:to_s)
XPath.first(ak, 'p').elements.map(&:to_s)
XPath.first(ak, 'p').elements.map(&:text)
p.elements.map(&:text)
p.texts
p = XPath.first(akalla, 'p')
akalla.texts
ak.to_s
ak = loaddiv '22-akalla'
akalla.to_s
akalla
actual
c
actual
q
child
child.value = child.to_s.gsub /^\)/, ''
child.value = child.to_s /^\)/, ''
child.value = child.to_s /
child
p.respond_to? :insert
p.respond_to? :insert_text
p.respond_to? :insert_tet
p.respond_to? :replace_text
p.respond_to? :replace
p.respond_to? :delete
p.respond_to? :add_text
p.respond_to? :delete_text
p.respond_to? :delete_element
p.texts.replace(2)
p.texts.replace(2, t)
t.to_s
t = Text.new 'foo'
p.texts.replace(2, Text.new 'foo')
p.texts.respond_to? :replace
p.texts[2]
p.texts[2] == child
p.texts[2]
p[2]
p.texts.index(child)
child.frozen?
child.methods.sort
child.to_s =~ /^\)/
child =~ /^\)/
child =~ /^
child.respond_to? :=~
child.respond_to? :=|
child.respond_to? :replace
child.respond_to? :gsub
child.to_s.gsub /^\)/, ''
child
q
p.to_s
p.delete child
p.to_s
p.respond_to? :delete
p.respond_to? :delete_text
p.respond_to? :add_texts
p.respond_to? :add_text
XPath.first(p, '/div/p/text()[3]') = ' '
XPath.first(p, '/div/p/text()[3]').respond_to? :text
XPath.first(p, '/div/p/text()[3]').respond_to? :text=
XPath.first(p, '/div/p/text()[3]').class
XPath.first(p, '/div/p/text()[3]')
p.texts.index(child)
p.texts.map(&:object_id)
child.object_id
child
p.texts.class
XPath.first(p, '/div/p/text()[3]')
XPath.first(p, '/div/p/text()[0]')
XPath.first(p, '/div/p/text()[2]')
XPath.first(p, '/div/p/text()')
XPath.first(p, '/div/p/text(0)')
XPath.first(p, '/div/p/text(2)')
p.text.xpath
p.texts[0].xpath
p.texts[2]
XPath.first(p, '/div/p/text()')
p.texts[2].xpath
p.texts[2].methods.sort
p.texts[2].methods(false)
p.texts[2].to_s
p.texts[2].class
p.text
p.texts[2] = ' '
p.texts[2]
p.texts]2
p.texts
todelete.map(&:to_s)
child.map(&:to_s)
child
q
qy
child.to_s
child
q
child.to_s
child
state
c
child.to_s
child
state
q
p.each { |child| puts child.class }
p.each { 
child
state
c
state
child
c
child
c
q
child.to_s
c
child.to_s
child
c
n
child.to_s
child
state
n
state
child
n
child
n
child.to_s.gsub /\($/, ''
child.to_s.gsub /
child.to_s
child.is_opening_parenthesis?
child.is_opening_parenthesis?]
n
state
child.to_s
c
child.to
child.to_s
child.to+s
c
child
